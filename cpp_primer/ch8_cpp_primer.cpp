#include <iostream>

using namespace std;

int main (){


}

/*
8.1 IO类
    为了支持这些不同种类的io处理操作,在istream和ostream之外,标准库还定义了其他一些io类型.
    iostream定义了用于读写溜的基本类型,fsream定义读写命名文件的类型,sstream定义了读写内存string对象的类型
    io类型间的关系
        本届剩下部分所介绍的标准库流特性都可以无差别地应用与普通流,文件流和string流,以及char或宽字符溜版本
io对象无拷贝或赋值
    ofstream out, out2;         //不能对流对象赋值
    out1 = out2;                //不能初始化ofstream参数
    out2 = print(out2);         //错误:不能拷贝流对象

    由于不能拷贝io对象,因此我们也不能将形参或返回类型设置为流类型.
    进行io操作的函数通常以引用方式传递和返回流.读写一个io对象会改变其状态,因此传递和返回的引用不能是const的
条件状态
    io操作一个与生俱来的问题是可能发生错误.下面是一个io错误的例子:
        int ival;
        cin >> ival;
    如果我们在标准输入上键入Boo,读操作就会失败.代码中的输入运算符期待读取个int,但得到一个字符B,这样cin进入错误状态.
    类似的,如果我们输入一个文件结束标识,cin也会进入错误状态.
    
    一个流一旦发生错误,其上后续的io操作都会失败.只有当一个流处于无错状态时,才可以从它读取数据,向它写入数据.
    由于流可能处于错误状态,因此代码通常应该在使用一个流之前检查它是否处于良好状态.确定一个流对象的状态的最简单方法是将其当作一个条件来用:
        whille(cin >> word)
            // ok : 读操作成功
    while循环检查 >> 表达式返回的流状态.如果输入操作成功,流保持有效状态,则条件为真.
查询流状态
    将流作为条件使用,只能告诉流是否有效,而无法告诉我们具体发生了什么



 */