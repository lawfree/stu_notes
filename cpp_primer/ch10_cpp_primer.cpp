#include <iostream>

using namespace std;

int main (){


}

/*
泛型算法

标准库并未给每个容器添加大量功能,而是提供一组算法,这些算法中的大多数都独立于任何特定的容器.这些算法是通用的(generic 泛型): 他们可以用于不同类型的容器和不同类型的元素

顺序容器只定义了很少的操作: 多数情况,我们可以添加和删除元素,访问首尾元素,确定容器是否为空以及获得指向首元素或尾元素之后位置的迭代器.
我们还需要其他很多有用的操作:查找特定元素,替换或删除一个特定值,重排元素顺序等.

标准库并未给每个容器都定义成员函数来实现,而是定义了一组泛型算法,实现一些经典算法的公共接口,排序和搜索.

10.1概述
    这些算法并不直接操作容器,而是遍历由两个迭代器指定的一个元素范围来操作.假如一个int的vector,希望知道里面是否含有一个特定值:
        int val = 42;
        // 如果vec 中找到想要的元素,则返回结果指向它,否则返回结果为 vec.cend()
        auto result = find (vec . cbegin () , vec.cend() , val);
        //报告结果
        cout << "The value " << val
             << (result == vec.cend() ? ...) << endl;
    传递个find前两个参数是表示元素范围的迭代器,第三个参数是一个值
        string val = "a value";         //我们要查找的值
        //此调用在list 中查找string 元素
        auto result = find(lst . cbegin() , lst.cend() , val)；
        //从ia[1]开始,直到(但不包含)ia[4]的范围内查找元素
        auto result = find(ia + 1 , ia + 4 , val);
    迭代器令算法不依赖于容器, 但算法依赖于元素类型的操作

    note: 算法永远不会执行容器的操作
        泛型算法本身不会执行容器的操作,它们智慧运行与迭代器之上,执行迭代器的操作.
        算法永远不会改变底层容器的大小.算法可能改变容器中保存的元素的值,也可能在容器内移动元素,但永远不会直接添加或删除元素.
只读算法
    一些算法只会读取其输入范围内的元素,而从不改变元素.find就是这样一种算法,另一个是accumulate,它定义在头文件numeric中.
    三个参数,前两个指定范围,第三个是和的初值
        //对vec中 元素求和
        int sum = accumulate( vec.cbegin(), vec.cend(), 0);
    由于string定义了+运算符,所以我们可以通过调用accumulate来将vector中所有string元素链接起来:
        String sum = accumulate(v.cbegin() , v.cend() , string(""));
    
    对于只读取而不改变元素的算法,通常最好使用cbegin()和cend() ,但是,如果你计划使用算法返回的迭代器来改变元素的值,就需要用begin()和end()作为参数
    操作两个序列的算法
        另一个只读算法是equal,用于确定两个序列是否保存相同的值.它将第一个序列中的每个元素和第二个序列中的对应元素都相等.则返回true
        此算法接受三个迭代器:前两个表示第一个序列中的元素范围,第三个表示第二个序列的首元素:
            //roster2 中的元素数目应该至少与roster1一样多.
            equal (roster1.cbegin() , roster1.cend() , roster2.cbegin());
        可以调用equal来比较两个不同类型的容器中的元素.

    那些只接受一个单一迭代器来表示第二个序列的算法,都假定第二个序列至少与第一个序列一样长.
写容器元素的算法
    算法fill 接受一对迭代器表示一个范围,还接受一个值作为第三个参数.fill将给定的这个值赋予输入序列中的每个元素.
        fill(vec.begin(), vec.end(), 0);        //将每个元素置0
        fill(vec.begin(), vec.begin() + vec.size()/2 , 10);     //将容器一个子序列设置为10
    介绍back_inserter
    拷贝算法
        拷贝是另一个向目的位置迭代器指向的输出序列中的元素写入数据的算法.此算法接受三个迭代器,前两个表示一个输入范围,第三个表示目的序列的起始位置.
        此算法将输入范围中的元素拷贝到目的序列中.传递给copy的目的序列至少要包含与输入序列一样多的元素.
            int a1[] = {0,1,2,3,4,5,6,7,8,9};
            int a2[sizeof(a1) / sizeof(*a1)];       //a2和a1一样大
            //ret 指向拷贝到a2的尾元素之后的位置
            auto ret = copy(begin(a1) , end(a1) , a2);  //a1的内容拷贝给a2
重排容器元素的算法
    sort会重排输入序列中的元素,使之有序,它是利用元素类型的 < 运算符来实现排序的
    消除重复单词
        void elimDups(vector<string> &words){
            //按字典排序words,以便查找重复单词
            sort(words.begin(), words.end());
            //unique重排输入范围,使得每个单词只出现一次
            //排列在范围前部,返回指向不重复区域之后一个位置的迭代器
            auto end_unique = unique(words.begin() , words.end());
            //使用向量操作erase删除重复单词
            words.erase(end_unique,words.end());
        }

        sort算法接受两个迭代器,表示要排序的元素范围.这里我们排序整个vector.
    使用unique
        unique算法重排输入序列,将相邻的重复项"消除",并返回一个指向不重复范围末尾的迭代器
        words的大小并未改变,它仍有10个元素,但这些元素的顺序被改变了--相邻的重复元素被"删除"了.我们将删除打引号是因为unique并不删除任何元素,
        它只是覆盖相邻的重复元素,使得不重复元素出现在序列开始部分.unique返回的迭代器指向最后一个不重复元素之后的位置.
        此位置之后的元素仍然存在,但我们不知道它们的值是什么.

        标准库算法对迭代器而不是容器进行操作.因此算法不能直接添加或删除元素
    使用容器操作删除元素
        为了真正第删除无用元素,必须使用容器操作,这里用erase.我们删除从end_unique开始直到words末尾的范围内所有元素

10.3 定制操作

10.4 再探迭代器

10.5 泛型算法结构
                        迭代器类别
    输入迭代器          只读,不写;单遍扫描,只能递增
    输出迭代器          只写,不读;单遍扫描,只能递增
    向前迭代器          可读写;多遍扫描,只能递增
    双向迭代器          可读写;多遍扫描,可递增递减
    随机访问迭代器       可读写;多遍扫描,支持全部迭代器运算
5类迭代器
    迭代器类别
        输入迭代器: 可以读取序列中的元素.一个输入迭代器必须支持
            用于比较两个迭代器的相等和不相等运算符(== !=)
            用于推进迭代器的前置和后置递增运算(++)
            用于读取元素的解引用运算符(*):解引用只会出现在赋值运算符的右侧
            箭头运算符(->).等价于(*it).number
        输出迭代器:撸看作输入迭代器功能上的补集--只写而不读元素.输出迭代器必须支持
            用于推进迭代器的前置和后置递增运算(++)
            解引用运算符(*),只出现在赋值运算符的左侧

            我们只能向一个输出迭代器赋值一次.类似输入迭代器,输出迭代器只能用于单遍扫描算法.用作目的位置的迭代器通常是输出迭代器.
        向前迭代器: 可以读写操作.这类迭代器只能在序列中沿一个方向移动.
        双向迭代器
        随机访问迭代器:提供在常量时间内访问序列中任意元素的能力
                    此类迭代器支持双向迭代器的所有功能,此外还支持表中的操作:
            用于两个迭代器相对位置的关系运算符(< <= >=)
            迭代器和一个整数值的加减运算(+,+=,-和-=),计算结果是迭代器在序列中前进给定整数个元素后的位置
            用于两个迭代器上的减法运算符(-),得到两个迭代器的距离
            下标运算符(iter[n],与*(iter[n]))等价
        算法sort要求随机访问迭代器,array,deque,string和vector的迭代器都是随机访问迭代器,用于访问内置数组元素的指针也是.
算法形参模式
    在任何其他算法分类上,还有一组参数规范,理解这些参数规范对学习新算法很有帮助
        alg(beg, end, other, args);
        alg(beg, end, dest, other args);
        alg(beg, end, beg2, other args);
        alg(beg, end, beg2, end2, other args);

10.6特定容器算法




*/