#include <iostream>
#include <vector>

using namespace std;

int main (){
    vector<int> a(3,0);
    vector<int> b (4,1);
    swap(a,b);
    cout << a[3]<< endl;    // 1

    return 0;
}

/*
一个容器就是有些特定类型对象的集合.顺序容器sequential container为程序员提供了控制元素存储和访问顺序的能力.这种顺序不依赖于元素的值,
而是与元素加入容器时的位置相对应.

9.1顺序容器概述
    下表列出了标准库中的顺序容器,所有顺序容器都提供了快速顺序访问元素的能力.但是这些容器在以下方面都有不同的性能折中:
        向容器添加或从容器中删除元素的代价
        非顺序访问容器中元素的代价
                                顺序容器类型
        vector          可变大小数组,支持随机快速随机访问.在尾部之外的位置插入或删除元素可能很慢
        deque           双端队列.支持快速随机访问,在头尾位置插入/删除速度很快
        list            双向链表.只支持双向顺序访问.在list中任何位置进行插入/删除操作速度都很快
        forward_list    单向链表.只支持单向顺序访问.在链表任何位置进行插入/删除操作速度很快
        array           固定大小数组.支持快速随机访问,不能添加或删除元素
        string          与vector相似的容器.但专门用于保存字符.随机访问快.在尾部插入/删除速度快
    确定使用哪种顺序容器
        通常,用vector,除非有很好的理由用其他的
9.2 容器库概览
    某些操作是所有容器类型都提供的.
    另外一些操作仅针对顺序容器,关联容器或无序容器
    还有一些操作只适用于一小部分容器
    对容器可以保存的元素类型的限制
        顺序容器可以保存几乎任何类型的元素.
迭代器
    与容器一样,迭代器有着公共接口:如果一个迭代器提供某个操作,那么所有提供相同操作的迭代器对这个操作的实现方式都是相同的.
    迭代器范围
        一个迭代器范围由一对迭代器表示,两个迭代器分别指向同一个容器中的元素或者是尾元素之后的位置.这两个迭代器通常被称为begin和end
        这种元素范围称为左闭合区间区间
        对构成范围的迭代器的要求
            如果满足如下条件,两个迭代器begin和end构成一个迭代器范:
                他们指向同一个容器中的元素,或者是容器最后一个元素之后的位置
                我们可以通过反复递增begin来达到end.换句话说,end不在begin之前
容器类型成员
begin和end成员
    begin和end操作生成指向容器中第一个元素和尾元素之后位置的迭代器.这两个迭代器最常见的用途是形成一个包含容器中所有元素的迭代器范围.
    begin和end有多个版本:带r的版本返回反向迭代器;以c开头的版本返回const迭代器
        //显式指定类型
        list<string>::iterator it5 = a.begin();
容器定义和初始化
    每个容器类型都定义了默认构造函数
    将一个容器初始化为另一个容器的拷贝
        为了创建一个容器为另一个容器的拷贝,两个容器的类型及其元素类型必须匹配.
        当将一个容器初始化为另一个容器的拷贝时,两个容器的容器类型和元素类型都必须相同
    与顺序容器大小相关的构造函数
        只有顺序容器的构造函数才接受大小参数,关联容器并不支持
    标准库array具有固定大小
        与内置数组一样,标准库array的大小也是类型的一部分.当定义一个array时,除了指定元素类型,还要指定容器大小:
            array<int , 42>     //保存42个int的数组
    赋值和swap
        赋值运算符将其左边容器中的全部元素替换为右边容器中元素的拷贝:
            c1 = c2;            //将c1的内容替换为c2中元素的拷贝
            c1 = {a , b , c};   //赋值后,c1大小为3
        第一个赋值运算后,左边容器将与右边容器相等.如果两个容器原来大小不同,赋值运算后两者的大小都与右边容器的原大小相同.第二个赋值运算后,c1的size变为3    
    使用swap
        swap操作交换两个相同类型容器的内容.调用swap之后,两个容器中的元素将会交换:
            vector<string> svec1(10);
            vector<string> svec2(24);
        调用swap后,svec1将包含24个string元素,svec2将包含10个string
关系运算符
    如果两个容器具有相同大小且所有元素都两两对应相等,则这两个容器相等;否则两个容器不等
    如果两个大小不等.但较小容器中每个元素都等于较大容器中的对应元素,则较小容器小于较大容器.
    如果两个容器都不是另一个容器的前缀子序列,则他们的比较结果取决于第一个不想等的元素的比较结果

9.3顺序容器操作
 */