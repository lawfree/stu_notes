如果某个方法不能够采用正常的途径完整它的任务，就可以通过另外一个路径退出方法。在这种情况下，方法并不返回任何值， 而是抛出
( throw) 一个封装了错误信息的对象。需要注意的是，这个方法将会立刻退出，并不返回任何值。
此外，调用这个方法的代码也将无法继续执行，取而代之的是，异常处理机制开始搜索能够处理这种异常状况的异常处理器 （exception handler)。

                    Throwable
                        |
        Error                           Exception
           |                                |
                                IOException     RuntimeException
                                    |                   |


在设计 Java 程序时， 需要关注 Exception 层次结构。 这个层次结构又分解为两个分支：
一个分支派生于 RuntimeException ; 另一个分支包含其他异常。划分两个分支的规则是：
    由程序错误导致的异常属于 RuntimeException :
    而程序本身没有问题， 但由于像 I/O 错误这类问题导致的异常属于其他异常:
派生于 RuntimeException 的异常包含下面几种情况：
•错误的类型转换。
•数组访问越界 i
•访问 null 指针
不是派生于 RuntimeException 的异常包括：
•试图在文件尾部后面读取数据。
•试图打开一个不存在的文件。
•试图根据给定的字符串查找 Class 对象， 而这个字符串表示的类并不存在,，

“ 如果出现 RuntimeException 异常， 那么就一定是你的问题” 是一条相当有道理的规则。
应该通过检测数组下标是否越界来避免 ArrayIndexOutOfBoundsException 异常；应该通过在使用变量之前检测是否为 null 来杜绝 NullPointerException 异常的发生：


在自己编写方法时， 不必将所有可能抛出的异常都进行声明。至于什么时候需要在方法
中用 throws 子句声明异常， 什么异常必须使用 throws 子句声明， 需要记住在遇到下面 4 种
情况时应该抛出异常：
1 ) 调用一个抛出受査异常的方法， 例如， FileInputStream 构造器。
2 ) 程序运行过程中发现错误， 并且利用 throw语句抛出一个受查异常（下一节将详细地介绍 throw 语句)。
3 ) 程序出现错误， 例如，a[-1]=0 会抛出一个 ArrayIndexOutOfBoundsException 这样的非受查异常。
4 ) Java 虚拟机和运行时库出现的内部错

总之，一个方法必须声明所有可能抛出的受查异常， 而非受查异常要么不可控制（ Error),要么就应该避免发生（ RuntimeException)。如果方法没有声明所有可能发生的受查异常， 编
译器就会发出一个错误消息。
当然， 从前面的示例中可以知道：除了声明异常之外， 还可以捕获异常。这样会使异常不被抛到方法之外，也不需要 throws 规范。稍后，将会讨论如何决定一个异常是被捕获，还
是被抛出让其他的处理器进行处理。


java.lang.Throwable 1.0
•Throwable( )
    构造一个新的 Throwable 对象， 这个对象没有详细的描述信息。
•Throwable(String message )
    构造一个新的 throwable 对象， 这个对象带有特定的详细描述信息。习惯上，所有派生的异常类都支持一个默认的构造器和一个带有详细描述信息的构造器。參 String getMessage( )获得 Throwabie 对象的详细描述信息。



7 . 2 捕获异常
到目前为止， 已经知道如何抛出一个异常。这个过程十分容易。只要将其抛出就不用理踩了。当然， 有些代码必须捕获异常。捕获异常需要进行周密的计划。这正是下面几节要介
绍的内容。
7 . 2.1 捕获异常
如果某个异常发生的时候没有在任何地方进行捕获，那程序就会终止执行，并在控制台上打印出异常信息， 其中包括异常的类型和堆栈的内容。对于图形界面程序（applet 和应用
程序，) 在捕获异常之后，也会打印出堆桟的信息，但程序将返回到用户界面的处理循环中
    try{
        code
        ...
    }catch(ExceptionType e){
        handler for this type
    }


7.4.1 断言的概念
假设确信某个属性符合要求， 并且代码的执行依赖于这个属性。例如， 需要计算
    double y = Math.sqrt(x);
我们确信，这里的 X 是一个非负数值。原因是：X 是另外一个计算的结果，而这个结果不可能是负值；或者 X 是一个方法的参数，而这个方法要求它的调用者只能提供一个正整数。
然而，还是希望进行检查， 以避免让“ 不是一个数” 的数值参与计算操作。当然，也可以抛出一个异常：
    if (x < 0) throw new 111egalArgumentException("x < 0");
但是这段代码会一直保留在程序中， 即使测试完毕也不会自动地删除。如果在程序中含有大量的这种检查，程序运行起来会相当慢。
断言机制允许在测试期间向代码中插入一些检査语句。当代码发布时，这些插人的检测语句将会被自动地移走。
Java 语言引人了关键字 assert。这个关键字有两种形式：
    assert 条件；
    assert 条件：表达式；
注释：“ 表达式” 部分的唯一目的是产生一个消息字符串。AssertionError 对象并不存储
表达式的值， 因此， 不可能在以后得到它。正如 JDK 文档所描述的那样： 如果使用表达
式的值， 就会鼓励程序员试图从断言中恢复程序的运行， 这不符合断言机制的初衷。
要想断言?c 是一个非负数值， 只需要简单地使用下面这条语句
    assert x >= 0;
或者将 x 的实际值传递给 AssertionError 对象， 从而可以在后面显示出来。
    assert x >= 0 : x;

